<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classeur-downloader.js.html":{"id":"classeur-downloader.js.html","title":"Source: classeur-downloader.js","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Source: classeur-downloader.js 'use strict' const _ = require('lodash'), ApiClient = require('classeur-api-client'), async = require('async'), fs = require('fs-extra'), pathMod = require('path'), pathJoin = _.spread(pathMod.join), TreeManipulator = require('tree-manipulator') // const eyes = require('eyes'), p = eyes.inspect.bind(eyes) /** * Module for downloading and listing files and folders stored in [Classeur](http://classeur.io/). * * @example &lt;caption&gt;Installation&lt;/caption&gt; * npm install classeur-downloader * @example &lt;caption&gt;Saving a single file's markdown content&lt;/caption&gt; * const downloader = require('classeur-downloader') * downloader.saveSingleFile({ * file: 'some file ID', * userId: 'user ID', * apiKey: 'api key', * path: '/some/path.md', * markdown: true * }, (error) =&gt; { * if (error) throw error * }) * @example &lt;caption&gt;Saving directories&lt;/caption&gt; * // Saves all files contained in 'folder1' and 'folder2' in subdirectories of mydir/ with those same names: * downloader.saveTree({ * folders: ['folder1', 'folder2' ] * userId: 'user ID', * apiKey: 'api key', * path: 'mydir/', * markdown: true * }, (error) =&gt; { * if (error) throw error * }) * @see The [README](index.html) for an overview and more usage examples. * @see The [source code]{@link https://github.com/zbentley/classeur-downloader} on GitHub. * @see The [classeur-api-client](http://zbentley.github.io/classeur-api-client/versions/latest) module (which `classeur-downloader` is built around) for a lower-level way to interact with the Classeur API. * @module classeur-downloader */ function getTree(byId, print, items) { let props = { identifierProperty: byId ? 'id' : 'name', nestedNodesProperty: 'files', } if ( print ) { props.valueGetter = function(obj, property) { // If we're getting the value of a node, and not its children, // stringify it for pretty printing. if (property === this.identifierProperty) { return APIobjectToString(obj, byId) } else { return obj[property] } } } let tm = new TreeManipulator(props) // If contents are supplied, bind the instance methods used by this script // to the contents to prevent having to pass around tree manipulators *and* // contents everywhere. if ( items !== undefined ) { _.mixin(tm, { print: _.partial(tm.print, items), findNode: _.partialRight(tm.findNode, items) }) } return tm } function errorIfExists(path, cb) { fs.stat(path, (error, result) =&gt; { if (error &amp;&amp; error.errno === -2) { //ENOENT cb(null, result) } else { cb(error || new Error(`File ${path} exists, and --overwrite is not set.`), null) } }) } function getWriter(path, options, addExtension, content) { const writefunc = _.isString(content) ? fs.outputFile : fs.outputJson path = pathJoin(path) if ( addExtension ) { path += _.isString(content) ? '.md' : '.json' } return options.overwrite ? _.partial(writefunc, path, content) : _.partial(async.series, [ _.partial(errorIfExists, path), _.partial(writefunc, path, content), ]) } // For each item in the tree, either download it, or make the folder and recurse. function makeFolderOrSaveFile(conn, tree, options, id, cb) { const found = tree.findNode(id), kids = tree.nestedNodesProperty, node = found.node, parallel = [], markdown = options.markdown let path = found.path if ( _.has(node, kids) ) { // Handle creation of folder metadata file only applies in JSON mode, // and only applies to non-root nodes. if ( options.folderMetadata &amp;&amp; path.length &gt; 1 ) { path[path.length - 1] += '.folder_metadata.json' parallel.push(getWriter(path, options, false, node)) } parallel.push(_.partial(async.each, node[kids], (child, cb) =&gt; { makeFolderOrSaveFile(conn, tree, options, child[tree.identifierProperty], cb) })) } else { parallel.push(_.partial(async.waterfall,[ _.bind(conn.getFile, conn, node.id), function(result, cb) { getWriter(path, options, options.addExtension, markdown ? result.content.text : result)(cb) } ])) } async.parallel(parallel, cb) } // Print a tree rooted at each folder and file. Printing the top-level tree // results in leading \\____ parent relationships for no reason. function showTree(items, conn, options, cb) { const tm = getTree(options.byId, true) // TODO group by files vs. folders. _.forEach(_.sortBy(items, tm.identifierProperty), _.bind(tm.print, tm)) cb(null, null) } function saveTree(items, conn, options, cb) { const path = options.path makeFolderOrSaveFile(conn, getTree(options.byId, false, { id: path, name: path, files: items // top-level folders and manually-specified files }), options, path, cb) } function APIobjectToString(object, byId) { if ( object.id || object.name ) { let info = [object.id, object.name] if ( byId ) info.reverse() return `${info.pop()} (${info.pop()})` } else { return '' } } function getFilesAndFolders(options, func, cb) { const conn = new ApiClient(options.userId, options.apiKey, options.host) async.parallel( [ (cb) =&gt; { conn.getFolders(options.folders, cb) }, (cb) =&gt; { conn.getFiles(options.files, cb) }, ], (error, result) =&gt; { if (error) { if ( ! _.isError(error) ) { error = new Error(error) } cb(error, null) } else { // _.flatten de-'segments' the array into a single list of files and folders. func(_.flatten(result), conn, options, cb) } } ) } function assertOptions(options, maxFiles, maxFolders) { options.folders = options.folders || [] options.files = options.files || [] if ( ! _.isUndefined(maxFiles) &amp;&amp; options.files.length &gt; maxFiles ) { throw new Error(`Got ${options.files.length} files, but expected no more than ${maxFiles}:\\n${options.files}`) } if ( ! _.isUndefined(maxFolders) &amp;&amp; options.folders.length &gt; maxFolders ) { throw new Error(`Got ${options.folders.length} folders, but expected no more than ${maxFolders}:\\n${options.folders}`) } if ( _.isUndefined(options.addExtension) ) { options.addExtension = true } return options } function scrubCallback(cb) { return (error, result) =&gt; { result = _.compact(_.flattenDeep(result)) cb(error || null, _.isEmpty(result) ? null : result) } } /** * Options for configuring `classeur-downloader`. * @typedef {Object} Options:Global * @property {String} userId - User ID with which to connect to the Classeur API. * @property {String} apiKey - API key to use when connecting to the Classeur API. This can be obtained by re-generating your key in the Classeur 'User' preferences pane. * @property {String[]} [files] - Array of file IDs to operate on. * - At least one value must be supplied in `options.files` or `options.folders`, otherwise an error will be raised. * @property {String[]} [folders] - Array of folder IDs to operate on. * - At least one value must be supplied in `options.files` or `options.folders`, otherwise an error will be raised. * @property {boolean} [byId=false] - If true, files and folders will be handled (saved or printed) by ID. If false, they will be handled by Classeur human-readable name. */ /** * Options for configuring the bulk download behavior of `classeur-downloader`. * All options used by {@link module:classeur-downloader~Options:Global} are also accepted. * @typedef {Object} Options:DownloadFilesAndFolders * @property {String} path - Destination path to save files and folders from Classeur. `path` must be an existent, writable folder. * - All files in `options.files` will be saved inside of `path`. All folders in the `options.folders` will be created (with names according to the `byId` property) in `path`, and the files they contain will be created within those folders. * - If `options.overwrite` is not set and name collisions occur with files being saved into `path`, an error will be raised and save operations will halt. Partial results may exist on the filesystem. * @property {boolean} [overwrite=false] - If true, items in `path` that already exist will be overwritten. * @property {boolean} [folderMetadata=false] - If true, generate JSON folder metadata for all folders in `folders`. * - If `true`, a single JSON file will be created next to every Classeur folder downloaded. That JSON file will be named after the folder, and will end in `.folder_metadata.json`. It will contain the full Classeur API metadata information for the folder. This is usually not useful, unless you are using `classeur-downlaoder` to back up a locally-hosted Classeur instance with the intent of using the generated files for some future restoration process. * @property {boolean} [markdown=false] - Whether or not to write markdown content for files. * - If `true`, saved files' content will be the markdown content of Classeur documents. * - If `false`, files' content will be their full JSON data from Classeur. Full JSON data objects include markdown content and other fields, and will likely not be able to be opened directly in a Markdown editor. * @property {boolean} [addExtension=true] - Whether or not appropriate extensions should be added to files written. * - If `true`, files saved with `options.markdown` set to `true` will have the `.md` extension, and files saved outside of `markdown` mode will have the `.json` extension. * - If false, extensions will not be added to files. */ /** * Options for configuring the single-file download behavior of `classeur-downloader`. * All options used by {@link module:classeur-downloader~Options:Global} are also accepted. * @typedef {Object} Options:DownloadSingleFile * @property {String} path - Destination path to save files and folders from Classeur. Must be either a nonexistent path in a writable directory, or an existent, writable file (if `options.overwrite` is set). * @property {String} [file=options.files[0]] - Single file ID to download and save. If not provided, `options.files[0]` will be used. * - This option is mutually exclusive with `options.files`. * @property {boolean} [overwrite=false] - If true, `path` will be overwritten with the new Classeur file content retrieved. * @property {boolean} [markdown=false] - Whether or not to write markdown content for `options.file`. * - If `true`, `options.file`'s content will be that file's markdown content, visible in the Classeur UI. * - If `false`, `options.file`'s content will be its full JSON data from Classeur. Full JSON data objects include markdown content and other fields, and will likely not be able to be opened directly in a Markdown editor. */ /** * @callback CompletionCallback * @param {Error?} error - An throwable Error (or subclass thereof) if an error occurrend. * - For errors in writing files, `error` may be any of the errors raised by the [fs](https://nodejs.org/api/fs.html) module. * - For errors retrieving data from the Classeur API, `error` may be one of the Error subclasses used by [classeur-api-client](http://zbentley.github.io/classeur-api-client/versions/latest). Errors will be supplied to `CompletionCallback`s in the same way they will be supplied to [ClasseurClient~ScrubbedCallback](http://zbentley.github.io/classeur-api-client/versions/latest/module-classeur-api-client.html#.ScrubbedCallback)s. * - `error` will always be `null` (not `undefined` or another falsy value) if no error occurred. * @param {*?} result - Behavior of `result` is not defined it should not be used. Will usually be `null`. May sometimes contain an array of partial result objects. */ /** * @summary Prints out (to the console) a tree structure of the Classeur hierarchy of supplied files and folders. * @param {module:classeur-downloader~Options:Global} options - Options for which Classeur files and folders to retrieve, and how to display them. * - Folders in the `options.folders` will be printed as root directories, and all of the files they contain will be printed. * - If the `options.byId` is `true`, files and folders will be printed out as 'id (name)'. Otherwise, they will be printed as 'name (id)', where 'name' is the human-readable name of an object in the Classeur UI. * @param {module:classeur-downloader~CompletionCallback} callback - Called with an error, if one occurred, or `null` if all operations were successful. */ module.exports.showTree = (options, cb) =&gt; { getFilesAndFolders(assertOptions(options), showTree, scrubCallback(cb)) } /** * Folders in the `options.folders` array will be saved as root directories (with names determined by the presence or absence of `options.byId`), and all of the files they contain will be saved within them. Files in `options.files` will be saved at the top level. * If the `options.byId` is `true`, files and folders' root names will be their Classeur object IDs. Extensions will be added regardless of `options.byId`, depending on the value of `options.addExtension`. * @summary Saves Classeur files and folders to a specified path on the local filesystem. * @param {module:classeur-downloader~Options:DownloadFilesAndFolders} options - Options for which Classeur files and folders to retrieve, and how to save them. * @param {module:classeur-downloader~CompletionCallback} callback - Called with an error, if one occurred, or `null` if all operations were successful. * * @example &lt;caption&gt;Saving files by ID&lt;/caption&gt; * // Assume the folder with ID 'abcd' contains files with the IDs 'foo', 'bar', and 'baz'. * const downloader = require('classeur-downloader') * downloader.saveTree({ * files: [ 'quux' ], * folders: [ 'abcde' ], * userId: 'user ID', * apiKey: 'api key', * path: 'mydir/', * folderMetadata: true * }, (error) =&gt; { if (error) throw error }) * // 'mydir' will now contain: * // quux.json * // abcde.folder_metadata.json * // abcde * // \\_ foo.json * // \\_ bar.json * // \\_ baz.json * * @example &lt;caption&gt;Saving markdown content&lt;/caption&gt; * // Assume the folder with ID 'abcd' has the UI-visible name 'My Folder'. * // Assume it contains two files with IDs 'foo' and 'bar', and the names 'My Stuff' and 'My Other Stuff'. * downloader.saveTree({ * folders: [ 'abcde' ], * userId: 'user ID', * apiKey: 'api key', * path: 'mydir/' * markdown: true * }, (error) =&gt; { if (error) throw error }) * // 'mydir' will now contain: * // My Folder * // \\_ My Stuff.md * // \\_ My Other Stuff.md */ module.exports.saveTree = (options, cb) =&gt; { getFilesAndFolders(assertOptions(options), saveTree, scrubCallback(cb)) } /** * This function can be used when you don't need/want to create container folders for your retrieved Classeur content. * @summary Saves a single Classeur file to a specified path on the local filesystem. * @param {module:classeur-downloader~Options:DownloadSingleFile} options * - `options.folders` may not be supplied to this function. * - `options.byId` is ignored by this function. * - File content will be saved directly to `options.path` no folders or other metadata files will be created. * - File extensions (e.g. `.md`) will _not_ be added by SaveSingleFile write the extension you want into `options.path` directly. * @param {module:classeur-downloader~CompletionCallback} callback - Called with an error, if one occurred, or `null` if all operations were successful. * * @example &lt;caption&gt;Saving a single file's markdown content&lt;/caption&gt; * const downloader = require('classeur-downloader') * downloader.saveSingleFile({ * files: 'some file id', * userId: 'user ID', * apiKey: 'api key', * path: 'myfile.markdown', * markdown: true * }, (error) =&gt; { if (error) throw error }) */ module.exports.saveSingleFile = (options, cb) =&gt; { options = assertOptions(options, 1, 0) const conn = new ApiClient(options.userId, options.apiKey, options.host), ext = pathMod.parse(options.path).ext async.waterfall([ _.bind(conn.getFile, conn, options.file || options.files[0]), (result, cb) =&gt; { getWriter([options.path], options, false, options.markdown ? result.content.text : result)(cb) } ], scrubCallback(cb)) } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Modules × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions classeur-downloader 0.1.3 classeur-downloaderScript to download files and folders from http://classeur.io/ Classeur is an online writing and collaboration platform by the creators of StackEdit. Documents created and shared within Classeur are stored in HTML local storage and in Classeur's cloud/servers. classeur-downloader can be used to download files and folders out of Classeur and onto a local filesystem. This module is built around classeur-api-client. Documentation and SourcesDocumentation for this module (both the module API and the cldownload script) is available on GitHub pages. For documentation on older or unreleased package versions, go here. Source code for this package is avaiable at https://github.com/zbentley/classeur-downloader. InstallationYou can install the downloader script and library globally: npm install -g classeur-downloader cldownload --help...Or locally: npm install classeur-downloader ./node_modules/.bin/cldownload --helpUsageCommand-line Interfacecldownload [global options] list|save [subcommand options]The cldownload CLI operates over any number of Classeur files or folders, has two modes of operation: list (display a tree of file names and IDs retrieved) and save (save files and folders to the filesystem). The below examples all assume you are using a globally-installed copy of classeur-downloader. If you are running it locally, use the local path (usually node_modules/.bin/cldownloader) where appropriate. Options are detected by the shortest unambiguous substring, so --file works just as well as --files. All options have short versions or synonyms. Use the various --help flags to see valid option names. Examples# Save markdown content of all files in two folders to a directory: cldownload --user-id 'my id' --api-key 'my key' save --folders 'folder id 1' 'folder id 2' --save-path /path/to/dir --markdown # Save the full Classeur API metadata and data for a file into a single JSON document: cldownload --user-id 'my id' --api-key 'my key' save --file 'file id' --save-path /path/to/a/file.json # Print out a tree of all files in a given folder: cldownload --user-id 'my id' --api-key 'my key' list --folder 'folder id' # Global help: cldownload --help # Subcommand-specific help: cldownload list --help cldownload save --helpGlobal OptionsThe following options apply to all subcommands and should be specified before the subcommand name. --user-id ID (String) Classeur user ID to use when connecting to the REST API. --api-key KEY (String) Classeur user API key (visible only once, in the web UI wen generated) to use when connecting to the REST API. --help Print the help message for global options and subcommand names, and then exit. --version Print the version of the cldownload script and associated NPM package, and then exit. 'save' Subcommand Options --destination DESTINATION (Path; must be nonexistent or an empty directory) Path in which to save downloaded data. If more than one file and/or folder is specified for download, or if DESTINATION ends with a trailing slash, then DESTINATION must be an existent, writable, directory. Otherwise, it must be a nonexistent path inside an existent, writable directory. If --overwrite is not set and DESTINATION is a directpry, DESTINATION should empty; otherwise name collisions will cause an error, and partial results may be written into the directory. --folders FOLDER_ID_1 FOLDER_ID_2 ... (One or more strings) Folder(s) to download. Each folder will be created (in parallel) inside of DESTINATION, with either the name visible in the Classeur UI or the folder ID (depending on the --by-id setting). All files inside each folder will then be downloaded into that directory. --files FILE_ID_1 FILE_ID_2 ... (One or more strings) File(s) to download. Each file will be downloaded (in parallel) and placed in the appropriate folder inside of DESTINATION, with either the name visible in the Classeur UI or the folder ID (depending on the --by-id setting). If a single file ID and no folders are supplied to cldownload, DESTINATION will be written to as a file, not a directory, unless DESTINATION ends with a trailing slash. In this mode, a file extension (.md or .json) will not be appended to the downloaded file. --by-id If set, files and folders will be created in DESTINATION with names corresponding to their Classeur IDs rather than their UI-visible names. --overwrite If set, files with the same names as ones already in DESTINATION will be overwritten. If not set, errors will be raised when name conflicts occur. However, partial results may still be written to paths without name conflicts. --markdown If set, extensions of downloaded files will be .md, and the content of each downloaded file will be the markdown content of the Classeur document that file represents, as visible in the UI. If not set, extensions of downloaded files will be .json, and the content of each downloaded file will be the full JSON information for that document from the Classeur REST API. The full information contains the markdown content as well as other metadata fields, so it cannot be opened in another Markdown editor without modification. File extensions are not added if the only a single file is being downloaded directly to a file path, and is not being placed in a directory. See --files for more info. --help Print the help message for the save subcommand, and then exit. 'list' Subcommand Options --help Print the help message for the list subcommand, and then exit. --folders FOLDER_ID_1 FOLDER_ID_2 ... (One or more strings) Folder(s) to list. Each folder will be printed at the root of a tree of the files it contains. How each folder is displayed depends on whether or not --by-id is set. --files FILE_ID_1 FILE_ID_2 ... (One or more strings) File(s) to list. Each file will be printed out at the root level, alongside any folders. Folders' content will be nested below them, but explicitly specified files will not (even if a folder which also contains an explicitly specified file is also specified). How each file is displayed depends on whether or not --by-id is set. --by-id If set, files and folders will be displayed with their Classeur object IDs first, and their UI-visible names in parentheses. If not set, files and folders will be displayed with their UI-visible names first, and their Classeur object IDs in parentheses. Module APIcldownload is a thin wrapper around the underlying classeur-downloader module API. That API can be used directly. For example, to get all files in a folder, do the following: const downloader = require('classeur-downloader'); // Saves all files contained in 'folder1' and 'folder2' in subdirectories of mydir/ with those same names: downloader.saveTree({ folders: ['folder1', 'folder2' ] userId: 'user ID', apiKey: 'api key', path: 'mydir/', markdown: true }, (error) =&gt; { if (error) throw error; });For complete documentation (generated via JSDoc embedded in this module's code), go to GitHub pages. For documentation on older or unreleased package versions, go here. Using IDsThe REST API operates only by ID. You cannot get any information by human-visible name; you have to use the object IDs of files and folders to retrieve them using classeur-downloader. The IDs of files are visible in the URI bar of Classeur (if you are using Classeur in a browser). IDs of other objects, including files, are visible via the 'properties' windows of those objects in the Classeur UI. Making ChangesSee the Developer's Guide for more info. NPM package versions will follow Semantic Versioning. BugsFile a GitHub issue on the main repository. Release NotesRelease notes are available here, under the &quot;Release Notes&quot; heading. × Search results Close "},"module-classeur-downloader.html":{"id":"module-classeur-downloader.html","title":"Module: classeur-downloader","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Module: classeur-downloader Module for downloading and listing files and folders stored in Classeur. Source: classeur-downloader.js, line 13 See: The README for an overview and more usage examples. The source code on GitHub. The classeur-api-client module (which classeur-downloader is built around) for a lower-level way to interact with the Classeur API. Examples Installation npm install classeur-downloader Saving a single file's markdown content const downloader = require('classeur-downloader') downloader.saveSingleFile({ file: 'some file ID', userId: 'user ID', apiKey: 'api key', path: '/some/path.md', markdown: true }, (error) =&gt; { if (error) throw error }) Saving directories // Saves all files contained in 'folder1' and 'folder2' in subdirectories of mydir/ with those same names: downloader.saveTree({ folders: ['folder1', 'folder2' ] userId: 'user ID', apiKey: 'api key', path: 'mydir/', markdown: true }, (error) =&gt; { if (error) throw error }) Methods &lt;static&gt; saveSingleFile(options, callback) Saves a single Classeur file to a specified path on the local filesystem. This function can be used when you don't need/want to create container folders for your retrieved Classeur content. Parameters: Name Type Description options module:classeur-downloader~Options:DownloadSingleFile options.folders may not be supplied to this function. options.byId is ignored by this function. File content will be saved directly to options.path no folders or other metadata files will be created. File extensions (e.g. .md) will not be added by SaveSingleFile write the extension you want into options.path directly. callback module:classeur-downloader~CompletionCallback Called with an error, if one occurred, or null if all operations were successful. Source: classeur-downloader.js, line 339 Example Saving a single file's markdown content const downloader = require('classeur-downloader') downloader.saveSingleFile({ files: 'some file id', userId: 'user ID', apiKey: 'api key', path: 'myfile.markdown', markdown: true }, (error) =&gt; { if (error) throw error }) &lt;static&gt; saveTree(options, callback) Saves Classeur files and folders to a specified path on the local filesystem. Folders in the options.folders array will be saved as root directories (with names determined by the presence or absence of options.byId), and all of the files they contain will be saved within them. Files in options.files will be saved at the top level. If the options.byId is true, files and folders' root names will be their Classeur object IDs. Extensions will be added regardless of options.byId, depending on the value of options.addExtension. Parameters: Name Type Description options module:classeur-downloader~Options:DownloadFilesAndFolders Options for which Classeur files and folders to retrieve, and how to save them. callback module:classeur-downloader~CompletionCallback Called with an error, if one occurred, or null if all operations were successful. Source: classeur-downloader.js, line 315 Examples Saving files by ID // Assume the folder with ID 'abcd' contains files with the IDs 'foo', 'bar', and 'baz'. const downloader = require('classeur-downloader') downloader.saveTree({ files: [ 'quux' ], folders: [ 'abcde' ], userId: 'user ID', apiKey: 'api key', path: 'mydir/', folderMetadata: true }, (error) =&gt; { if (error) throw error }) // 'mydir' will now contain: // quux.json // abcde.folder_metadata.json // abcde // \\_ foo.json // \\_ bar.json // \\_ baz.json Saving markdown content // Assume the folder with ID 'abcd' has the UI-visible name 'My Folder'. // Assume it contains two files with IDs 'foo' and 'bar', and the names 'My Stuff' and 'My Other Stuff'. downloader.saveTree({ folders: [ 'abcde' ], userId: 'user ID', apiKey: 'api key', path: 'mydir/' markdown: true }, (error) =&gt; { if (error) throw error }) // 'mydir' will now contain: // My Folder // \\_ My Stuff.md // \\_ My Other Stuff.md &lt;static&gt; showTree(options, callback) Prints out (to the console) a tree structure of the Classeur hierarchy of supplied files and folders. Parameters: Name Type Description options module:classeur-downloader~Options:Global Options for which Classeur files and folders to retrieve, and how to display them. Folders in the options.folders will be printed as root directories, and all of the files they contain will be printed. If the options.byId is true, files and folders will be printed out as 'id (name)'. Otherwise, they will be printed as 'name (id)', where 'name' is the human-readable name of an object in the Classeur UI. callback module:classeur-downloader~CompletionCallback Called with an error, if one occurred, or null if all operations were successful. Source: classeur-downloader.js, line 270 Type Definitions CompletionCallback(error, result) Parameters: Name Type Argument Description error Error &lt;nullable&gt; An throwable Error (or subclass thereof) if an error occurrend. For errors in writing files, error may be any of the errors raised by the fs module. For errors retrieving data from the Classeur API, error may be one of the Error subclasses used by classeur-api-client. Errors will be supplied to CompletionCallbacks in the same way they will be supplied to ClasseurClient~ScrubbedCallbacks. error will always be null (not undefined or another falsy value) if no error occurred. result * &lt;nullable&gt; Behavior of result is not defined it should not be used. Will usually be null. May sometimes contain an array of partial result objects. Source: classeur-downloader.js, line 254 Options:DownloadFilesAndFolders Options for configuring the bulk download behavior of classeur-downloader. All options used by module:classeur-downloader~Options:Global are also accepted. Type: Object Properties: Name Type Argument Default Description path String Destination path to save files and folders from Classeur. path must be an existent, writable folder. All files in options.files will be saved inside of path. All folders in the options.folders will be created (with names according to the byId property) in path, and the files they contain will be created within those folders. If options.overwrite is not set and name collisions occur with files being saved into path, an error will be raised and save operations will halt. Partial results may exist on the filesystem. overwrite boolean &lt;optional&gt; false If true, items in path that already exist will be overwritten. folderMetadata boolean &lt;optional&gt; false If true, generate JSON folder metadata for all folders in folders. If true, a single JSON file will be created next to every Classeur folder downloaded. That JSON file will be named after the folder, and will end in .folder_metadata.json. It will contain the full Classeur API metadata information for the folder. This is usually not useful, unless you are using classeur-downlaoder to back up a locally-hosted Classeur instance with the intent of using the generated files for some future restoration process. markdown boolean &lt;optional&gt; false Whether or not to write markdown content for files. If true, saved files' content will be the markdown content of Classeur documents. If false, files' content will be their full JSON data from Classeur. Full JSON data objects include markdown content and other fields, and will likely not be able to be opened directly in a Markdown editor. addExtension boolean &lt;optional&gt; true Whether or not appropriate extensions should be added to files written. If true, files saved with options.markdown set to true will have the .md extension, and files saved outside of markdown mode will have the .json extension. If false, extensions will not be added to files. Source: classeur-downloader.js, line 223 Options:DownloadSingleFile Options for configuring the single-file download behavior of classeur-downloader. All options used by module:classeur-downloader~Options:Global are also accepted. Type: Object Properties: Name Type Argument Default Description path String Destination path to save files and folders from Classeur. Must be either a nonexistent path in a writable directory, or an existent, writable file (if options.overwrite is set). file String &lt;optional&gt; options.files[0] Single file ID to download and save. If not provided, options.files[0] will be used. This option is mutually exclusive with options.files. overwrite boolean &lt;optional&gt; false If true, path will be overwritten with the new Classeur file content retrieved. markdown boolean &lt;optional&gt; false Whether or not to write markdown content for options.file. If true, options.file's content will be that file's markdown content, visible in the Classeur UI. If false, options.file's content will be its full JSON data from Classeur. Full JSON data objects include markdown content and other fields, and will likely not be able to be opened directly in a Markdown editor. Source: classeur-downloader.js, line 241 Options:Global Options for configuring classeur-downloader. Type: Object Properties: Name Type Argument Default Description userId String User ID with which to connect to the Classeur API. apiKey String API key to use when connecting to the Classeur API. This can be obtained by re-generating your key in the Classeur 'User' preferences pane. files Array.&lt;String&gt; &lt;optional&gt; Array of file IDs to operate on. At least one value must be supplied in options.files or options.folders, otherwise an error will be raised. folders Array.&lt;String&gt; &lt;optional&gt; Array of folder IDs to operate on. At least one value must be supplied in options.files or options.folders, otherwise an error will be raised. byId boolean &lt;optional&gt; false If true, files and folders will be handled (saved or printed) by ID. If false, they will be handled by Classeur human-readable name. Source: classeur-downloader.js, line 211 × Search results Close "},"tutorial-DeveloperGuide.html":{"id":"tutorial-DeveloperGuide.html","title":"Tutorial: Developer's Guide","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Developer's Guide Developer's GuidePull requests are welcome! Pull the source code and hack away. TestsTests are a work in progress now, and will be released soon. DocumentationBuilding the Main DocumentationDocumentation is generated, and, optionally, pushed to GitHub pages via a grunt-based build process. Generated documentation is placed in doc/generated. The doc/generated folder will be removed and re-created as part of any documentation build. To generate documentation from the JSDoc in the code, do grunt doc:master or grunt doc:current-version. The names of the two functions are a bit deceptive: both will generate documentation from the branch and version of the module from which you are running grunt. The difference is that the former places the documentation into the doc/generated/master file, and the latter places it in the doc/generated/$version file, where $version is the NPM package version from package.json. Building the Version Index Documentationgrunt doc:index can be used to build just the documentation landing page, which contains links to multiple module versions' documentation. grunt doc:index is implied as part of all other grunt doc tasks. The index will live in doc/generated/index.html. Unless you build a version's documentation in addition to the index, links in the index will not work. Pushing Documentation to GitHub PagesYou can add :push to either the doc:master or doc:current-version Grunt task to push the resulting documentation product to GitHub pages, e.g. grunt doc:master:push. Before pushing, the build system will delete and re-create the index documentation (regardless of target), and documentation for the version-named (or master-named) folder you are targeting, depending on which Grunt task you're pushing with. × Search results Close "},"tutorial-VersionIndex.html":{"id":"tutorial-VersionIndex.html","title":"Tutorial: Other Versions","body":" classeur-downloader Modules classeur-downloader Tutorials Developer's GuideOther Versions Other Versions classeur-api-clientThis is the documentation landing page for classeur-api-client, a node.js client for the REST API of http://classeur.io/. Source code for this package is avaiable at https://github.com/zbentley/classeur-downloader. Select a version of this library below to get started. VersionsNPM package versions will follow Semantic Versioning. Each link below will take you to the README for the given package version: latest stable 0.1.0 (links to 0.1.1 documentation) 0.1.1 0.1.2 development/unstable (master) Release Notes0.1.0 Initial release. 0.1.1 Fix a packaging bug that made cldownload inaccessible in some global installs. 0.1.2 Fix #1: incompatibility with older NodeJS versions. Make node &gt;=5.0 dependency explicit. Add release notes. Misc documentation updates for readability. Fixed some broken links. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
